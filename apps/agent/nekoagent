#!/usr/bin/env sh
set -eu

PROG="nekoagent"
INSTALL_DIR_DEFAULT="${HOME}/.local/bin"
INSTALL_DIR="${NEKO_INSTALL_DIR:-$INSTALL_DIR_DEFAULT}"
AGENT_BIN="${NEKO_AGENT_BIN:-$INSTALL_DIR/neko-agent}"
CONFIG_DIR="${NEKO_AGENT_CONFIG_DIR:-/etc/neko-agent}"
STATE_DIR="${NEKO_AGENT_STATE_DIR:-/var/run/neko-agent}"
AGENT_REPO="${NEKO_AGENT_REPO:-foru17/neko-master}"
VERSION="0.2.0"

log() {
  printf '[%s] %s\n' "$PROG" "$1"
}

err() {
  printf '[%s] error: %s\n' "$PROG" "$1" >&2
}

ensure_dirs() {
  mkdir -p "$CONFIG_DIR" "$STATE_DIR"
}

config_file() {
  name="$1"
  printf '%s/%s.env\n' "$CONFIG_DIR" "$name"
}

pid_file() {
  name="$1"
  printf '%s/%s.pid\n' "$STATE_DIR" "$name"
}

log_file() {
  name="$1"
  printf '%s/%s.log\n' "$STATE_DIR" "$name"
}

is_running() {
  name="$1"
  pf="$(pid_file "$name")"
  if [ ! -f "$pf" ]; then
    return 1
  fi
  pid="$(cat "$pf" 2>/dev/null || true)"
  if [ -z "$pid" ]; then
    return 1
  fi
  kill -0 "$pid" >/dev/null 2>&1
}

# ── Download helpers ────────────────────────────────────────────────────────

download_file() {
  url="$1"
  output="$2"
  if command -v curl >/dev/null 2>&1; then
    curl -fsSL "$url" -o "$output"
    return 0
  fi
  if command -v wget >/dev/null 2>&1; then
    wget -qO "$output" "$url"
    return 0
  fi
  err "curl or wget is required"
  exit 1
}

compute_sha256() {
  file="$1"
  if command -v sha256sum >/dev/null 2>&1; then
    sha256sum "$file" | awk '{print $1}'
    return 0
  fi
  if command -v shasum >/dev/null 2>&1; then
    shasum -a 256 "$file" | awk '{print $1}'
    return 0
  fi
  if command -v openssl >/dev/null 2>&1; then
    openssl dgst -sha256 "$file" | awk '{print $2}'
    return 0
  fi
  echo ""
}

normalize_os() {
  raw="$(uname -s | tr '[:upper:]' '[:lower:]')"
  case "$raw" in
    linux)  echo "linux" ;;
    darwin) echo "darwin" ;;
    *)
      err "unsupported OS: $raw"
      exit 1
      ;;
  esac
}

normalize_arch() {
  raw="$(uname -m | tr '[:upper:]' '[:lower:]')"
  case "$raw" in
    x86_64|amd64)       echo "amd64" ;;
    aarch64|arm64)      echo "arm64" ;;
    armv7l|armv7|armhf) echo "armv7" ;;
    mips)               echo "mips" ;;
    mipsle)             echo "mipsle" ;;
    *)
      err "unsupported architecture: $raw"
      exit 1
      ;;
  esac
}

# Query GitHub releases API for the latest agent tag (e.g. "agent-v0.2.0").
# Returns empty string on failure — callers must handle this gracefully.
get_latest_remote_tag() {
  repo="${1:-$AGENT_REPO}"
  api_url="https://api.github.com/repos/${repo}/releases/latest"
  tag=""
  if command -v curl >/dev/null 2>&1; then
    tag="$(curl -fsSL "$api_url" 2>/dev/null | awk -F'"' '/"tag_name"/{print $4; exit}')"
  elif command -v wget >/dev/null 2>&1; then
    tag="$(wget -qO- "$api_url" 2>/dev/null | awk -F'"' '/"tag_name"/{print $4; exit}')"
  fi
  printf '%s\n' "$tag"
}

# Return the version string reported by the local neko-agent binary, or "".
get_local_binary_version() {
  if [ -x "$AGENT_BIN" ]; then
    "$AGENT_BIN" --version 2>/dev/null | head -1 || true
  fi
}

# ── Update / download binary ────────────────────────────────────────────────

# Download, verify, and install a new neko-agent binary.
# Usage: do_download_binary <version_arg> <os> <arch>
#   version_arg: "latest" or "agent-v0.2.0" style tag
do_download_binary() {
  version_arg="$1"
  os="$2"
  arch="$3"

  if [ "$version_arg" = "latest" ]; then
    release_path="releases/latest/download"
    asset="neko-agent_${os}_${arch}.tar.gz"
  else
    # normalise: accept bare "0.2.0" or full "agent-v0.2.0"
    case "$version_arg" in
      agent-v*) tag="$version_arg" ;;
      v*)       tag="agent-${version_arg}" ;;
      *)        tag="agent-v${version_arg}" ;;
    esac
    release_path="releases/download/${tag}"
    asset="neko-agent_${tag}_${os}_${arch}.tar.gz"
  fi

  package_url="https://github.com/${AGENT_REPO}/${release_path}/${asset}"
  checksums_url="https://github.com/${AGENT_REPO}/${release_path}/checksums.txt"

  tmp_dir="$(mktemp -d)"
  # shellcheck disable=SC2064
  trap "rm -rf '$tmp_dir'" EXIT INT TERM

  archive_path="$tmp_dir/neko-agent.tar.gz"
  checksums_path="$tmp_dir/checksums.txt"

  log "downloading $package_url"
  download_file "$package_url" "$archive_path"

  log "verifying checksum..."
  download_file "$checksums_url" "$checksums_path"
  expected_hash="$(awk -v a="$asset" '$2 == a {print $1}' "$checksums_path" | head -n 1)"
  if [ -z "$expected_hash" ]; then
    err "cannot find checksum for $asset in checksums.txt"
    exit 1
  fi
  actual_hash="$(compute_sha256 "$archive_path")"
  if [ -z "$actual_hash" ]; then
    err "no sha256 tooling found (sha256sum / shasum / openssl)"
    exit 1
  fi
  if [ "$expected_hash" != "$actual_hash" ]; then
    err "checksum mismatch for $asset"
    err "  expected: $expected_hash"
    err "  actual:   $actual_hash"
    exit 1
  fi

  mkdir -p "$tmp_dir/extract"
  tar -xzf "$archive_path" -C "$tmp_dir/extract"

  new_binary="$tmp_dir/extract/neko-agent"
  if [ ! -f "$new_binary" ]; then
    err "extracted archive does not contain neko-agent"
    exit 1
  fi

  chmod +x "$new_binary"
  install_dir="$(dirname "$AGENT_BIN")"
  mkdir -p "$install_dir"
  mv "$new_binary" "$AGENT_BIN"
  log "binary installed: $AGENT_BIN"
}

# ── Commands ────────────────────────────────────────────────────────────────

version() {
  manager_ver="$VERSION"
  binary_ver="$(get_local_binary_version)"
  if [ -z "$binary_ver" ]; then
    binary_ver="(binary not found)"
  fi
  printf 'nekoagent  %s\n' "$manager_ver"
  printf 'neko-agent %s\n' "$binary_ver"
}

usage() {
  cat <<EOF
Neko Agent Manager v${VERSION}

Usage:
  $PROG init <name> [KEY=VALUE ...]          Create/overwrite config file
  $PROG add <name> [flags/options]           Quick add new backend instance
  $PROG start <name>                         Start agent instance
  $PROG stop <name>                          Stop agent instance
  $PROG restart <name>                       Restart agent instance
  $PROG status <name>                        Show instance status
  $PROG logs <name>                          Tail logs
  $PROG list                                 List configured instances
  $PROG update|upgrade <name> [version]      Update binary and restart
  $PROG remove <name>                        Remove instance config/runtime
  $PROG delete <name>                        Alias of remove
  $PROG uninstall                            Uninstall nekoagent + binaries
  $PROG version                              Show manager and binary version
  $PROG help                                 Show this help

Quick add with flags (auto-starts by default):
  $PROG add <name> \
    --server-url <url> \
    --backend-id <id> \
    --backend-token <token> \
    --gateway-type <clash|surge> \
    --gateway-url <url> \
    [--gateway-token <token>] \
    [--no-start]        # skip auto-start after add

Update examples:
  $PROG update home-surge              # update to latest release
  $PROG update home-surge agent-v0.2.0 # update to specific version

Config and runtime paths:
  CONFIG_DIR=$CONFIG_DIR
  STATE_DIR=$STATE_DIR
  AGENT_BIN=$AGENT_BIN

Required config keys:
  NEKO_SERVER, NEKO_BACKEND_ID, NEKO_BACKEND_TOKEN, NEKO_GATEWAY_TYPE, NEKO_GATEWAY_URL
Optional keys:
  NEKO_GATEWAY_TOKEN, NEKO_LOG, NEKO_AGENT_ID, NEKO_REPORT_INTERVAL,
  NEKO_HEARTBEAT_INTERVAL, NEKO_GATEWAY_POLL_INTERVAL, NEKO_REQUEST_TIMEOUT,
  NEKO_REPORT_BATCH_SIZE, NEKO_MAX_PENDING_UPDATES, NEKO_STALE_FLOW_TIMEOUT

Examples:
  # Add and start a new backend
  $PROG add home-surge --server-url http://10.0.0.210:3000 --backend-id 3 \\
    --backend-token ag_xxx --gateway-type surge --gateway-url http://10.0.0.210:9091 \\
    --gateway-token xxx

  # List all instances
  $PROG list

  # Check status
  $PROG status home-surge

  # View logs
  $PROG logs home-surge

  # Update to latest version
  $PROG update home-surge

  # Update to specific version
  $PROG update home-surge agent-v0.2.0

  # Remove instance
  $PROG remove home-surge
EOF
}

require_config_key() {
  key="$1"
  eval "val=\${$key:-}"
  if [ -z "$val" ]; then
    err "missing required key in config: $key"
    exit 1
  fi
}

load_config() {
  name="$1"
  cf="$(config_file "$name")"
  if [ ! -f "$cf" ]; then
    err "config not found: $cf"
    exit 1
  fi
  # shellcheck disable=SC1090
  . "$cf"
  require_config_key "NEKO_SERVER"
  require_config_key "NEKO_BACKEND_ID"
  require_config_key "NEKO_BACKEND_TOKEN"
  require_config_key "NEKO_GATEWAY_TYPE"
  require_config_key "NEKO_GATEWAY_URL"
}

build_agent_args() {
  set -- \
    --server-url "$NEKO_SERVER" \
    --backend-id "$NEKO_BACKEND_ID" \
    --backend-token "$NEKO_BACKEND_TOKEN" \
    --gateway-type "$NEKO_GATEWAY_TYPE" \
    --gateway-url "$NEKO_GATEWAY_URL"

  if [ -n "${NEKO_GATEWAY_TOKEN:-}" ]; then
    set -- "$@" --gateway-token "$NEKO_GATEWAY_TOKEN"
  fi
  if [ -n "${NEKO_AGENT_ID:-}" ]; then
    set -- "$@" --agent-id "$NEKO_AGENT_ID"
  fi
  if [ -n "${NEKO_REPORT_INTERVAL:-}" ]; then
    set -- "$@" --report-interval "$NEKO_REPORT_INTERVAL"
  fi
  if [ -n "${NEKO_HEARTBEAT_INTERVAL:-}" ]; then
    set -- "$@" --heartbeat-interval "$NEKO_HEARTBEAT_INTERVAL"
  fi
  if [ -n "${NEKO_GATEWAY_POLL_INTERVAL:-}" ]; then
    set -- "$@" --gateway-poll-interval "$NEKO_GATEWAY_POLL_INTERVAL"
  fi
  if [ -n "${NEKO_REQUEST_TIMEOUT:-}" ]; then
    set -- "$@" --request-timeout "$NEKO_REQUEST_TIMEOUT"
  fi
  if [ -n "${NEKO_REPORT_BATCH_SIZE:-}" ]; then
    set -- "$@" --report-batch-size "$NEKO_REPORT_BATCH_SIZE"
  fi
  if [ -n "${NEKO_MAX_PENDING_UPDATES:-}" ]; then
    set -- "$@" --max-pending-updates "$NEKO_MAX_PENDING_UPDATES"
  fi
  if [ -n "${NEKO_STALE_FLOW_TIMEOUT:-}" ]; then
    set -- "$@" --stale-flow-timeout "$NEKO_STALE_FLOW_TIMEOUT"
  fi

  log_enabled="${NEKO_LOG:-true}"
  set -- "$@" --log="$log_enabled"

  printf '%s\n' "$*"
}

cmd_init() {
  name="$1"
  shift
  ensure_dirs
  cf="$(config_file "$name")"
  umask 077
  : > "$cf"
  for kv in "$@"; do
    case "$kv" in
      *=*) printf '%s\n' "$kv" >> "$cf" ;;
      *)
        err "invalid key=value pair: $kv"
        exit 1
        ;;
    esac
  done
  log "config written: $cf"
}

# Quick add with flags instead of KEY=VALUE pairs
cmd_add() {
  if [ "$#" -lt 6 ]; then
    err "add requires: <name> --server-url <url> --backend-id <id> --backend-token <token> --gateway-type <type> --gateway-url <url>"
    echo ""
    echo "Usage: $PROG add <name> --server-url <url> --backend-id <id> --backend-token <token> --gateway-type <clash|surge> --gateway-url <url> [--gateway-token <token>] [--auto-start]"
    exit 1
  fi

  name="$1"
  shift

  # Parse flags
  server_url=""
  backend_id=""
  backend_token=""
  gateway_type=""
  gateway_url=""
  gateway_token=""
  auto_start="true"   # default: start immediately after add

  while [ "$#" -gt 0 ]; do
    case "$1" in
      --server-url)
        server_url="$2"
        shift 2
        ;;
      --backend-id)
        backend_id="$2"
        shift 2
        ;;
      --backend-token)
        backend_token="$2"
        shift 2
        ;;
      --gateway-type)
        gateway_type="$2"
        shift 2
        ;;
      --gateway-url)
        gateway_url="$2"
        shift 2
        ;;
      --gateway-token)
        gateway_token="$2"
        shift 2
        ;;
      --auto-start)
        auto_start="true"
        shift
        ;;
      --no-start)
        auto_start="false"
        shift
        ;;
      *)
        err "unknown flag: $1"
        exit 1
        ;;
    esac
  done

  # Validate required fields
  if [ -z "$server_url" ] || [ -z "$backend_id" ] || [ -z "$backend_token" ] || [ -z "$gateway_type" ] || [ -z "$gateway_url" ]; then
    err "missing required flags"
    echo "Required: --server-url, --backend-id, --backend-token, --gateway-type, --gateway-url"
    exit 1
  fi

  # Build config
  config_vars=""
  config_vars="$config_vars NEKO_SERVER=$server_url"
  config_vars="$config_vars NEKO_BACKEND_ID=$backend_id"
  config_vars="$config_vars NEKO_BACKEND_TOKEN=$backend_token"
  config_vars="$config_vars NEKO_GATEWAY_TYPE=$gateway_type"
  config_vars="$config_vars NEKO_GATEWAY_URL=$gateway_url"
  if [ -n "$gateway_token" ]; then
    config_vars="$config_vars NEKO_GATEWAY_TOKEN=$gateway_token"
  fi

  # Initialize config
  # shellcheck disable=SC2086
  cmd_init "$name" $config_vars

  log "instance '$name' added successfully"

  # Auto-start if requested
  if [ "$auto_start" = "true" ]; then
    cmd_start "$name"
  fi
}

cmd_start() {
  name="$1"
  ensure_dirs
  if [ ! -x "$AGENT_BIN" ]; then
    err "agent binary not found/executable: $AGENT_BIN"
    exit 1
  fi
  if is_running "$name"; then
    log "instance '$name' already running (pid $(cat "$(pid_file "$name")"))"
    exit 0
  fi

  load_config "$name"
  args="$(build_agent_args)"
  lf="$(log_file "$name")"
  pf="$(pid_file "$name")"

  # shellcheck disable=SC2086
  nohup "$AGENT_BIN" $args >> "$lf" 2>&1 &
  pid=$!
  printf '%s\n' "$pid" > "$pf"
  log "instance '$name' started, pid=$pid, log=$lf"
}

cmd_stop() {
  name="$1"
  pf="$(pid_file "$name")"
  if ! is_running "$name"; then
    rm -f "$pf"
    log "instance '$name' is not running"
    exit 0
  fi
  pid="$(cat "$pf")"
  kill "$pid" >/dev/null 2>&1 || true
  # Wait up to 12s for graceful shutdown (agent needs up to 10s for final flush)
  i=0
  while [ "$i" -lt 12 ] && kill -0 "$pid" >/dev/null 2>&1; do
    sleep 1
    i=$((i + 1))
  done
  if kill -0 "$pid" >/dev/null 2>&1; then
    kill -9 "$pid" >/dev/null 2>&1 || true
  fi
  rm -f "$pf"
  log "instance '$name' stopped"
}

cmd_status() {
  name="$1"
  if is_running "$name"; then
    log "instance '$name' is running (pid $(cat "$(pid_file "$name")"))"
    exit 0
  fi
  log "instance '$name' is stopped"
  exit 1
}

cmd_logs() {
  name="$1"
  lf="$(log_file "$name")"
  if [ ! -f "$lf" ]; then
    err "log file not found: $lf"
    exit 1
  fi
  tail -f "$lf"
}

cmd_list() {
  ensure_dirs
  found=false
  for f in "$CONFIG_DIR"/*.env; do
    if [ ! -e "$f" ]; then
      continue
    fi
    found=true
    name="$(basename "$f" .env)"
    if is_running "$name"; then
      status="running"
    else
      status="stopped"
    fi
    # Load config to show backend info
    # shellcheck disable=SC1090
    . "$f"
    printf '%-20s %-10s backend-id=%s gateway=%s\n' "$name" "$status" "${NEKO_BACKEND_ID:-?}" "${NEKO_GATEWAY_TYPE:-?}"
  done
  if [ "$found" = false ]; then
    log "no instances configured"
  fi
}

cmd_update() {
  name="$1"
  version_arg="${2:-latest}"

  os="$(normalize_os)"
  arch="$(normalize_arch)"

  # Determine the plain version string we're targeting (no "agent-v" prefix)
  if [ "$version_arg" = "latest" ]; then
    log "querying GitHub for latest release..."
    remote_tag="$(get_latest_remote_tag "$AGENT_REPO")"
    if [ -z "$remote_tag" ]; then
      err "failed to determine latest version from GitHub API"
      err "hint: check network access or specify a version: $PROG update $name agent-v0.2.0"
      exit 1
    fi
    target_plain="${remote_tag#agent-v}"
  else
    case "$version_arg" in
      agent-v*) target_plain="${version_arg#agent-v}" ;;
      v*)       target_plain="${version_arg#v}" ;;
      *)        target_plain="$version_arg" ;;
    esac
  fi

  # Check local binary version — skip download if already up-to-date
  local_version="$(get_local_binary_version)"
  if [ -n "$local_version" ] && [ "$local_version" = "$target_plain" ]; then
    log "binary already at $local_version, no download needed"
  else
    log "updating binary: ${local_version:-not installed} -> $target_plain"

    was_running=false
    if is_running "$name"; then
      was_running=true
      cmd_stop "$name"
    fi

    do_download_binary "$version_arg" "$os" "$arch"

    if [ "$was_running" = true ]; then
      cmd_start "$name"
    fi
  fi

  log "instance '$name' is at version $target_plain"
}

cmd_remove() {
  name="$1"

  if is_running "$name"; then
    cmd_stop "$name"
  fi

  rm -f "$(pid_file "$name")"
  rm -f "$(log_file "$name")"

  cf="$(config_file "$name")"
  if [ -f "$cf" ]; then
    rm -f "$cf"
  fi

  log "instance '$name' removed"
}

cmd_uninstall() {
  rm -f "$AGENT_BIN"
  rm -f "$INSTALL_DIR/nekoagent"
  rm -f "/usr/local/bin/neko-agent" "/usr/local/bin/nekoagent"
  log "binaries removed"
  log "note: instance config files remain in $CONFIG_DIR (use '$PROG remove <name>' if needed)"
}

main() {
  if [ "$#" -lt 1 ]; then
    usage
    exit 1
  fi

  cmd="$1"
  shift

  case "$cmd" in
    init)
      if [ "$#" -lt 2 ]; then
        usage
        exit 1
      fi
      cmd_init "$@"
      ;;
    add)
      if [ "$#" -lt 6 ]; then
        usage
        exit 1
      fi
      cmd_add "$@"
      ;;
    start|stop|restart|status|logs)
      if [ "$#" -ne 1 ]; then
        usage
        exit 1
      fi
      case "$cmd" in
        start)   cmd_start "$1" ;;
        stop)    cmd_stop "$1" ;;
        restart) cmd_stop "$1" || true; cmd_start "$1" ;;
        status)  cmd_status "$1" ;;
        logs)    cmd_logs "$1" ;;
      esac
      ;;
    update|upgrade)
      if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
        usage
        exit 1
      fi
      cmd_update "$@"
      ;;
    remove|delete)
      if [ "$#" -ne 1 ]; then
        usage
        exit 1
      fi
      cmd_remove "$1"
      ;;
    uninstall)
      if [ "$#" -ne 0 ]; then
        err "uninstall does not accept instance name; use '$PROG remove <name>'"
        usage
        exit 1
      fi
      cmd_uninstall
      ;;
    list)
      cmd_list
      ;;
    version|-v|--version)
      version
      ;;
    help|-h|--help)
      usage
      ;;
    *)
      err "unknown command: $cmd"
      usage
      exit 1
      ;;
  esac
}

main "$@"
